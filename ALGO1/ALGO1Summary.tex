% !TeX spellcheck = fr_FR ----------- %
% ----------------------------------- %
% ----SUMMARY-OF-ALGO-1-COURSE------- %
% ----------------------------------- %
% -@version-1.0---------------------- %
% -@author-Florestan-De-Moor--------- %
% ----------------------------------- %


\documentclass[10pt,a4paper]{article}

\usepackage[frenchb]{babel}

\usepackage[utf8]{inputenc}

\usepackage{amsmath}

\usepackage{amsfonts}

\usepackage{amssymb}

\usepackage{enumitem} % To set no item separation

% Redefine the itemize symbol
	\AtBeginDocument{\def\labelitemi{\( \vartriangleright \)}}

\begin{document}


\title{Algorithmique 1}
\author{L3 RI}
\date{}

\maketitle

\tableofcontents


\section{Algorithmes}

\subsection{Tris}

%
\begin{itemize}[noitemsep]
	\item Tri par insertion : \(  O(n^2)  \)
		
		Considérer chaque élément un à un pour l'insérer à sa bonne place (penser à un jeu de cartes)
		
	\item Tri fusion : \(  O(n\log n)  \)
		
		Paradigme diviser pour régner, diviser en deux sous-problèmes
	\item Tri Shell : \(  O(n^2)  \)
	
		Suite de tris par insertion sur chaque constituant d'une partition du tableau
		
	\item Tri par tas : \(  O(n\log n)  \)
	
		Utiliser une structure de file de priorité, ici un tas
	
        \item Tri sélection : $\mathcal{O}(n^2)$ %je crois qu'en théorie c'est ce O quil faut utiliser pour les notations de landau mais je me trompe peut-être

                Mettre le plus grand à sa place, puis le suivant... Peu d'écritures. Utilisé pour le tri fusion en place.

        \item Optimalité : \(  \Omega (n \log n)  \) nécessaire, arbres de décision
\end{itemize}
%



\subsection{Arbres binaires}

%
\begin{itemize}[noitemsep]
	\item Arbre binaire : \(  1+h \leq n \leq 2^{h+1}-1  \)
	\item Arbre binaire presque complet : %
		\(  2^h \leq n \leq 2^{h+1}-1  \)
	\item Tas
	\item Arbre binaire de recherche (ABR)
	
		La recherche d'un élément ne suit qu'une branche, problème si arbre non équilibré
	\item Arbre AVL
	
		Rééquilibrage d'un arbre par des rotations :
		\(  \log _2(n+1) \leq h \leq 1.44\log _2 n  \)
	
\end{itemize}
%



\subsection{Graphes}

%
\begin{itemize}[noitemsep]
	\item Graphes orientés, pondérés
	\item Implémentations par liste d'adjacence ou matrice d'adjacence
	\item Parcours en profondeur
	
		Valeurs de \texttt{pre} et \texttt{post} traitement, types d'arc, détection de cycles, tri topologique
		
		Composantes fortement  connexes, Algorithme de Kosaraju (un premier PP, puis un second PP dans l'ordre décroissant des temps de \texttt{post} sur le graphe transposé), graphe quotient
	\item Parcours en largeur
	
		Recherche d'un plus court chemin
		
		Algorithme de Dijkstra (mise à jour de distances, et considérer le sommet qui minimise)
		
		Algorithme A\(^*\) (même principe, mais le choix se base en plus sur une heuristique)
	\item Arbre couvrant de poids minimal
	
	Algorithme de Kruskal (utiliser une structure Union-Find, trier les arêtes par poids croissants, et les considérer toute une à une, si pas dans la même classe, on fusionne)
	
	Algorithme de Prim (similaire à Dijkstra, tant qu'il reste des sommets non traités, on prend l'arête qui minimise à partir d'un sommet traité)
\end{itemize}
%


\subsection{Algorithmes gloutons}

\begin{itemize}[noitemsep]
	\item Prendre un choix localement meilleur
	\item Algorithmes de Kruskal, de Prim
	\item Rendu de monnaie
	\item Couverture d'ensemble (exemple où le choix glouton ne donne pas forcément la solution optimale)
\end{itemize}


\subsection{Programmation dynamique}

\begin{itemize}[noitemsep]
	\item Paradigme de conception d'algorithmes
	\item Définir les sous-problèmes, en revoyant à la baisse l'objectif si nécessaire
	\item Trouver une relation de récurrence
	\item Écrire l'algorithme (mémoïzation)
	\item Exemples
	
		Recherche plus court chemin dans un graphe
		
	\begin{itemize}[noitemsep]
		\item Algorithme de Floyd-Warshall
		
		\( d_{i,j,k} = \) distance minimale d'un chemin allant de i à j %
		passant par les k premiers sommets 
		\item Algorithme de Bellman-Ford
		
		\( d_{i,j,k} = \) distance minimale d'un chemin allant de i à j %
		contenant au plus k arcs 
	\end{itemize}
		Recherche plus longue sous-suite croissante
		
		Problème du sac à dos
\end{itemize}


\subsection{Flots}

\begin{itemize}[noitemsep]
	\item Problème du flot maximal
	\item Algorithme de Ford-Fulkerson (Tant qu'il existe un chemin de la source à la cible dans le graphe résiduel, maximiser les flux sur ce chemin)
	\item L'algorithme se termine si les poids sont entiers (ou rationnels), sinon ne termine pas forcément
	\item Réduction du problème de couplage maximal au problème de flot maximal
\end{itemize}


\subsection{Programmation linéaire}

\begin{itemize}[noitemsep]
	\item Forme canonique
	\item Algorithme du simplexe (Tant qu'on peut maximiser la solution, échanger deux variables en utilisant l'expression la plus contraignante)
\end{itemize}


\section{Structures de données}

%
\subsection{Files de priorité}

Implémentées par exemple avec un tas.

Méthodes : 
\begin{itemize}[noitemsep]
	\item Enfiler
	\item Défiler un élément maximal
	\item Est vide?
	\item Construire file vide
\end{itemize}

\subsection{Tables de hachage}
	
Méthodes : 
\begin{itemize}[noitemsep]
	\item Ajout d'un élément
	\item Suppression d'un élément
	\item Contient x ?
\end{itemize}

Risque de collisions, n'est pas rare (idem paradoxe des anniversaires)

\subsection{Structure Union-Find}

Méthodes : 
\begin{itemize}[noitemsep]
	\item Créer partition
	\item Fusionner deux classes (union)
	\item Obtenir un représentant (find)
\end{itemize}

Implémentation par une forêt d'arbres. %
Complexité améliorée en utilisant la compression de chemin.

\section{Complexité}

\paragraph{Master Theorem} Soit $a \geq 1,~b \geq 0$ et $d \geq 2$. Si $T \in \mathbb{R}^{\mathbb{N}}$ vérifie 

\[ T(n) = a \cdot T \left( \dfrac{n}{d} \right) + O \left( n^b \right) \]

\noindent alors

\[
T(n) = \left\{
    \begin{array}{ll}
        O\left( n^b \right) & \mbox{si } b > \log_d(a) \\
        O\left(n^b log_d(n)\right) & \mbox{si } b = \log_d(a) \\
        O\left( n^{log_d(a)} \right) & \mbox{si } b < \log_d(a)
    \end{array}
\right.
\]

\section{Autres}

\begin{itemize}[noitemsep]
	\item Encodage de Huffman
	\item Formules de Horn
	\item FFT
	\item Classes P, NP, EXPTIME
	\item Classe NP : Réduction à SAT, Branch\&Bound, Local Search
\end{itemize}

\end{document}
